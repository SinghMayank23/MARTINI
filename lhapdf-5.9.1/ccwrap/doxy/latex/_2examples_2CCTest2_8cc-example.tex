\section{/examples/\+C\+C\+Test2.\+cc}
An example of a program using the C++ interface to \doxyref{L\+H\+A\+P\+DF}{p.}{namespaceLHAPDF} to calculate P\+DF errors.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Program to demonstrate usage of the MRST 2006 NNLO PDFs.    //}
\textcolor{comment}{// to calculate errors.                                        //}
\textcolor{comment}{}\textcolor{preprocessor}{#include "LHAPDF/LHAPDF.h"}
\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <cmath>}
\textcolor{preprocessor}{#include <cstdio>}
\textcolor{preprocessor}{#include <cstdlib>}
\textcolor{keyword}{using namespace }std;

\textcolor{keyword}{using namespace }LHAPDF;


\textcolor{keywordtype}{double} logdist\_x(\textcolor{keywordtype}{double} xmin, \textcolor{keywordtype}{double} xmax, \textcolor{keywordtype}{size\_t} ix, \textcolor{keywordtype}{size\_t} nx) \{
  \textcolor{keyword}{const} \textcolor{keywordtype}{double} log10xmin = log10(xmin);
  \textcolor{keyword}{const} \textcolor{keywordtype}{double} log10xmax = log10(xmax);
  \textcolor{keyword}{const} \textcolor{keywordtype}{double} log10x = log10xmin + (ix/\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(nx-1))*(log10xmax-log10xmin);
  \textcolor{keyword}{const} \textcolor{keywordtype}{double} x = pow(10.0, log10x);
  \textcolor{keywordflow}{return} x;
\}


\textcolor{keywordtype}{int} main() \{
  \textcolor{comment}{// Show initialisation banner only once}
  setVerbosity(LOWKEY); \textcolor{comment}{// or SILENT, for no banner at all}

  \textcolor{comment}{// You could explicitly set the path to the PDFsets directory}
  \textcolor{comment}{// setPDFPath("/home/whalley/local/share/lhapdf/PDFsets");}
  
  \textcolor{comment}{// Initialize PDF sets}
  \textcolor{keyword}{const} \textcolor{keywordtype}{string} NAME = \textcolor{stringliteral}{"MRST2006nnlo"};
  initPDFSetM(1, NAME, LHGRID);
  initPDFSetM(2, NAME, LHGRID);
  initPDFSetM(3, NAME, LHGRID);
  
  \textcolor{comment}{// Find the number of eigensets from numberPDF()}
  \textcolor{keyword}{const} \textcolor{keywordtype}{int} neigen = numberPDFM(1)/2;
  cout << \textcolor{stringliteral}{"Number of eigensets in this fit = "} << neigen << endl;
  \textcolor{comment}{// Find the min and max values of x and Q2 }
  \textcolor{keyword}{const} \textcolor{keywordtype}{double} xmin = getXmin(0);
  \textcolor{keyword}{const} \textcolor{keywordtype}{double} xmax = getXmax(0);
  cout << \textcolor{stringliteral}{"Valid x-range = ["} << xmin << \textcolor{stringliteral}{", "} << xmax << \textcolor{stringliteral}{"]"} << endl;
  \textcolor{comment}{// Number of x values to sample}
  \textcolor{keyword}{const} \textcolor{keywordtype}{int} nx = 10;
  \textcolor{comment}{// Set the Q scale and flavour}
  \textcolor{keywordtype}{double} q = 10;
  \textcolor{keywordtype}{int} flav = 4;

  \textcolor{comment}{// Get x's and central PDF values}
  initPDFM(1, 0);
  vector<double> fc(nx), x(nx);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ix = 0; ix < nx; ++ix) \{
    x[ix] = logdist\_x(xmin, 0.9*xmax, ix, nx);
    fc[ix] = xfxM(1, x[ix], q, flav);
  \}

  \textcolor{comment}{// Sum over error contributions (two ways, depending on how LHDPAF was compiled)}
  vector<double> summax(nx), summin(nx), sum(nx);
\textcolor{preprocessor}{  #ifndef LHAPDF\_LOWMEM}
  \textcolor{comment}{// This is the normal, efficient, way to do this, with the error}
  \textcolor{comment}{// sets being initialised the minimum number of times}
  cout << \textcolor{stringliteral}{"Using efficient set looping"} << endl;
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ieigen = 1; ieigen <= neigen; ++ieigen) \{
    initPDFM(2, 2*ieigen-1);
    initPDFM(3, 2*ieigen);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ix = 0; ix < nx; ++ix) \{
      \textcolor{comment}{// Find central and plus/minus values}
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} fp = xfxM(2, x[ix], q, flav);
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} fm = xfxM(3, x[ix], q, flav);
      \textcolor{comment}{// Construct shifts}
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} plus = max(max(fp-fc[ix], fm-fc[ix]),0.0);
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} minus = min(min(fp-fc[ix], fm-fc[ix]),0.0);
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} diff = fp-fm;
      \textcolor{comment}{// Add it together}
      summax[ix] += plus*plus;
      summin[ix] += minus*minus;
      sum[ix] += diff*diff;
    \}
  \}
\textcolor{preprocessor}{  #else}
  \textcolor{comment}{// In low memory mode, the sets need to be re-initialised with every }
  \textcolor{comment}{// change of member. Using the approach above gives wrong answers, and}
  \textcolor{comment}{// reinitialising in all the nested loops is sloooooow! The best way is }
  \textcolor{comment}{// to calculate the values, plus and minus errors separately.}
  cout << \textcolor{stringliteral}{"Using low-mem mode set looping"} << endl;
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ieigen = 1; ieigen <= neigen; ++ieigen) \{
    vector<double> fp(nx), fm(nx);
    initPDFM(2, 2*ieigen-1);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ix = 0; ix < nx; ++ix) \{
      fp[ix] = xfxM(2, x[ix], q, flav);
    \}
    initPDFM(3, 2*ieigen);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ix = 0; ix < nx; ++ix) \{
      fm[ix] = xfxM(3, x[ix], q, flav);
    \}
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} ix = 0; ix < nx; ++ix) \{
      \textcolor{comment}{// Construct shifts}
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} plus = max(max(fp[ix]-fc[ix], fm[ix]-fc[ix]), 0.0);
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} minus = min(min(fp[ix]-fc[ix], fm[ix]-fc[ix]), 0.0);
      \textcolor{keyword}{const} \textcolor{keywordtype}{double} diff = fp[ix]-fm[ix];
      \textcolor{comment}{// Add it together}
      summax[ix] += plus*plus;
      summin[ix] += minus*minus;
      sum[ix] += diff*diff;
    \}
  \}
\textcolor{preprocessor}{  #endif}

  \textcolor{comment}{// Print out results}
  cout << \textcolor{stringliteral}{"flavour = "} << flav << \textcolor{stringliteral}{"               Asymmetric (%)   Symmetric (%)"} << endl;
  cout << \textcolor{stringliteral}{"     x    Q**2    xf(x)    plus    minus      +-      "} << endl;
  \textcolor{keywordflow}{for}  (\textcolor{keywordtype}{int} ix = 0; ix < nx; ++ix) \{
    printf(\textcolor{stringliteral}{"%0.7f %.0f %10.2E %8.2f %8.2f %8.2f \(\backslash\)n"},
           x[ix], q*q, fc[ix], 
           sqrt(summax[ix])*100/fc[ix],
           sqrt(summin[ix])*100/fc[ix],
           0.5*sqrt(sum[ix])*100/fc[ix]);
  \}
  
  \textcolor{keywordflow}{return} EXIT\_SUCCESS;
\}



\textcolor{preprocessor}{#include "FortranWrappers.h"}
\textcolor{preprocessor}{#ifdef FC\_DUMMY\_MAIN}
\textcolor{keywordtype}{int} FC\_DUMMY\_MAIN() \{ \textcolor{keywordflow}{return} 1; \}
\textcolor{preprocessor}{#endif}
\end{DoxyCodeInclude}
 